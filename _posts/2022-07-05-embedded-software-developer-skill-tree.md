---
layout: post
title: "嵌入式软件工程师技能树"
lang: zh-CN
last_modified_at: 2022-07-05
author: togo.huang (zhihu.com)
no_ccbysav4: true
---
注：本文为转载，针对有一定复杂性（本文中为基于SoC芯片和各类DSP芯片的**机器人视觉系统和相机系统**）的嵌入式软件开发，不考虑工业控制中仅有MCU芯片的单片机开发。转载自知乎togo.huang的“机器人嵌入式系统设计”专栏：[当我们谈论嵌入式时我们究竟在谈什么](https://zhuanlan.zhihu.com/p/107144859)。

## 一、为何写本文

嵌入式是一个即形象又抽象的词，形象在于看到这个词会在脑海中有一个大概的画面，抽象在于这画面的马赛克有点多，看不清楚。所以说很多朋友会对嵌入式有很多疑问：
* [嵌入式行业真的没前途吗？](https://www.zhihu.com/question/272159066/answer/369581416)
* [嵌入式与单片机之间的关系是什么？](https://www.zhihu.com/question/315310041/answer/819296591)
* [是做嵌入式有前途还是做互联网软件比如前端有前途？](https://www.zhihu.com/question/371464785/answer/1014810771)
* [嵌入式算吃青春饭么？](https://www.zhihu.com/question/306621798/answer/557773811)
* [同是嵌入式工程师，为什么有人月薪8千，有人年薪快40万？](https://zhuanlan.zhihu.com/p/47359101)

看到这些疑问，我差点一口老血喷出来。技术的进步如此之快，现在的嵌入式技术早已今非昔比。我希望通过本文，能让广大有志于投身于此的朋友，揭示一个更“高清无码”的嵌入式。希望大家看过本文后， 能知道真正的高手是什么样的，而上面问题中提到的年薪40万，仅仅是一个起步。

需要说明的是，受作者的经历和认知所限，本文的表述是基于机器人视觉系统和相机系统展开的。这类系统对性能和实时性均有很高的要求，需要理解全技术链的方方面面，具有一定的代表性。

---

## 二、如何学以致用

凭空讲嵌入式工程师要干哪些事，比较枯燥。我想到一个比较好的切入点：分析各大企业嵌入式相关岗位JD（Job Description）中任职要求，看一下当今企业对嵌入式人员的技能需求。这就是大家努力的方向。

为此，我选择了机器人视觉领域（含自动驾驶）和相机领域的几个典型的企业进行分析。

选择的机器人视觉领域企业有：

* DJI：无人机领域的老大哥，第一次将视觉技术如此大规格地应用于消费电子产品中。
* 美团&NINEBOT：低速自动驾驶车代表企业。
* 小马智行：L4级别自动驾驶代表企业。
* 石头科技：家用扫地机器人代表企业。
* 地平线：人工智能芯片代表企业。

选择的相机领域企业有：
* OPPO：冲电5分钟，通话2小时（和相机没啥关系，不过这个广告词实在是太上头了）
* VIVO：逆光也清晰，照亮你的美。
* 小米：生死看淡，不服就干。

这些企业嵌入式相关的岗位也有很多（我已经很克制地归一化了相似的岗位名称）：
* 嵌入式系统工程师
* 嵌入式系统架构师
* linux嵌入式软件工程师
* BSP工程师
* 机器人系统软件开发工程师
* 系统开发工程师
* 系统软件工程专家
* 算法优化工程师
* 系统性能工程师
* 应用算法工程师
* 嵌入式AI平台工程师
* 系统软件中间件工程师

看到这么多岗位，大家是不是有一些吃惊？

随着移动计算能力的飞速发展，嵌入式技术早已今非昔比。记得十五年前刚接触嵌入式技术时，那时处理器的性能比现在低好几个数量级，当时的挑战是：

* 资源真的太少：曾用过128字节RAM的MCU，要仔细扣每一字节的使用，函数调用不能太深，一不小心栈就爆了。
* 实时性：大部分的应用是控制，需要在规定时间内完成规定任务。

总得来说，还是相对简单的，毕竟东西少，复杂度就有限。现在不一样啦，要面对全新的挑战：

* 计算性能永远不够：不得不说，现在最新的计算机视觉/AI算法在嵌入式平台上还跑不起来；所以选择算法时，一般会选当前平台能运行的最好算法，这就导致有多少CPU就用多少CPU，CPU占用率常年维持在90%以上。
* 内存永远不够：图像既吃空间又吃带宽，经常出现的问题是功能还没做完，内存用完了，oom满天飞。更隐晦的是内存带宽也会悄悄被耗尽，悄悄拖慢运行速度。
* 实时性要求也不低：虽然不似实时控制一样需要做到抖动在1ms以内，但做到30ms还是要要的，要不就丢帧了。如何在高CPU和内存占用率下保证实时性，是一项前所未有的挑战。
* 复杂度高：由于功能复杂度提升，引入了很多新的高级总线接口和协议栈，代码的规模也越来越大，要搞清全局，变得越来越困难。

这些新的挑战，映射到技术细节上，又可以归纳为以下方面：

* 编程技能：随着系统复杂度的提升，需要编程技能的要求也水涨船高。
* 处理器架构：当遭遇CPU和内存性能问题时，不懂点CPU架构，就像在猜哑迷一样。
* 操作系统：哇，oom了；哇，丢帧了；哇，写FLASH性能抖动了；只能边哇哇哇地哭边恶补内存管理，进程调度，文件系统知识了。
* 接口与驱动：接口越来越多，速度越来越快，现在这个年头，不懂十几个接口都听不懂小米的发布会了。
* Framework（中间件）：ROS,Camera Pipeline,各类协议栈，学好任何一个都不容易。
* 算法优化：处理器性能就像海绵里的水，拧一拧总能优化一点出来。
* 应用编程与调试：多线程，多进程，多核，线程间通信，进程间通信，多核间通信。对，就是这么纠结。
* 硬件知识：嵌入式工程师不懂点硬件知识哪能和硬件工程师愉快地玩耍呢？
* 其他：作为一个承上启下的岗位，对软技能有更高的要求。

---

## 三、编程技能
各代表企业非常一致地都对编程基础技能提出了要求，嵌入式工程师在大类上属于软件工程师的范畴，编程技能不能差，要不嘿嘿：编码一时爽，调试火葬场。。。

> DJI：精通C/C++。
> 美团：熟练掌握CMake/MAKEFILE的编写规则，熟悉交叉编译的基本流程。
> 小马智行：熟悉C/C++，熟悉至少一种脚本语言(Python/Shell), 有良好的开发习惯、文档规范及编码习惯；熟练掌握常用的数据结构和算法，精通STL。
> NINEBOT：具备成熟的大型嵌入式软件项目经验，对常见嵌入式软件设计的理念、流程、框架、工具有清晰的认知，熟练使用版本控制工具；熟悉常用算法和数据结构，C++开发有充足经验，熟悉面向对象设计，熟悉C++11标准。
> 石头科技：精通C语言，具备良好的编程习惯、代码质量意识、代码阅读能力，熟悉汇编语言者优先考虑；熟悉Linux下的C语言、Python以及Shell，具备良好的编程习惯、代码质量意识、代码阅读能力。
> OPPO：良好的编程习惯，精通C/C++，了解Linux系统，了解一些脚本语言（Linux Shell\Dos Shell\Perl\Matlab）。
> VIVO：精通嵌入式系统的C和汇编语言混合编程，有良好的编码习惯和文档规范，对代码质量和执行效率精益求精；，有程序架构设计经验，对软件的模块化、可移植性和项目重构有深入理解。
> 小米：熟悉linux下各种工具链的制作，熟悉MAKEFILE、Linux，有Builtroot、Docker实际使用经验者优先。
> 地平线：精通C/C++语言，掌握现代C++标准库和常用扩展库的用法；精通现代主流的C++设计模式；主导过大型复杂AI系统的架构设计，对软件分层、模块划分、接口定义等有独到心得。

总结下来，需要掌握以下技能：

* C/C++：C和C++仍旧是嵌入式开发绝对主流的语言。底层软件这么多年来，一直是C的天下，在可预见的将来，不会改变。随着系统复杂度越来越高，越来越多的应用层软件采用C++来编写。需要注意的是：一些平台的工具链（如大多数DSP，一些RTOS）对C++的支持不好，经常出现你以为编译器帮你做了实际却没做，或是编译器偷偷做了一些你不知道的事情。所以在用C++的时候需要留个心眼，要不出了问题真的是一脸蒙B。另外，一些新语言（如rust）一直在快速发展，未来有可能在嵌入式应用开发中开花结果。
* 汇编语言：用于玩弄一些底层的奇淫巧技（有兴趣可以去查看Kernel的一些很底层的代码，例如锁的实现代码），有时也用于向算法工程师秀肌肉（汇编级优化）。
* 其他语言：主要是脚本语言，用于平时做些小工具（Shell），和机器学习工程师愉快对话（Python）。
* 版本管理：git是个好东西～
* 构建：工程越来越大，构建越来越复杂，如何把代码编译出来，也成了一个学问。MAKEFILE太麻烦，那就来搞CMake吧。软件包太多？Buildroot搞起。构建再往深引申，又可以引出CI（持续集成），这又是一个很大的话题了。
* 软件工程：工程复杂度提升带来的是需要利用软件工程的思想进行管理，软件设计的理念，流程，框架开始提到台面来进行研究，越高级的岗位对这方面的要求越高。

---

## 四、处理器架构
根据产品种类的不同，大部分企业都提出了对处理器架构的要求：

> 美团：熟练掌握至少一种单片机编程（Atmel/STM32），并至少有3年以上相关开发经验。
> 小马智行：精通ARM、DSP或者其他CPU。
> NINEBOT：精通STM32单片机、ARM处理器的架构及应用开发，具有RK & 高通硬件设备开发经验优先；
> 石头科技：有长期嵌入式ARM、DSP、Cortex-M等架构的开发经验；熟练掌握至少一种MCU的体系结构，熟练使用ARM Cortex-A或M系列内核的SOC。
> OPPO：至少精通其中一种嵌入式体系架构者（包括ARM，DSP，X86，MIPS，GPU等）。
> VIVO：深入理解ARM架构，熟悉MCU开发工具；

* ARM：需要了解Cortex-M和Cortex-A系列处理器架构。好了，问题来了，什么叫了解处理器架构？哈佛架构，冯氏架构，多级流水线都是最基础的常识；SIMD/MIMD/指令预取/乱序执行这些概念也要懂一些；cache多少line多少way多少级代表什么对性能有什么影响也要心知肚明。如果还能搞清楚为什么大核（Cortex-A72）比小核（Cortex-A53）性能要高，就更好了。能回答这些问题，应该就能说了解ARM架构了。
* DSP/GPU：DSP和GPU在大规模并行运算上有得天独到的优势。不过现在ARM的NEON性能越来越强，也可以算半个DSP了。相对于很久以前TI DSP独步天下，现在的DSP会作为SOC芯片其中一类处理核心而存在，常见的IP有CEVA和Tensilica。我曾参与的项目中大量使用了DSP，只有了解其体系结构，才能炸干其性能，并且在遇到问题时不至于毫无头绪。我遇到过因DSP处理器微结构设计特性引起的小概率bug，教训惨痛，记忆尤新啊。随着深度学习应用的崛起，GPU用得也越来越多，框架一般会做的比较好，用起来相对简单，但要做深层次的优化，亦非易事。
* SOC架构：这部分在各公司的JD中都没有体现，但我觉得是一个关键技能点。需要了解处理器的总线设计，例如AXI上开了多少个port，每个port的带宽是多少？这对DDR内存带宽有瓶颈的应用非常关键。需要了解cache设计和多核通信IP，有助于了解异构多核间通信的原理与可能潜在的cache一致性风险。

总之这部分了解深了可以很深，会步入SOC设计领域。插拨一个题外话：作者在进行校园招聘时，拜访过很多高校的计算机学院。发现真正在做计算机体系结构研究的实验室非常少，大部分实验室其实是在做计算机应用研究。这可能与目前的社会需求有关，但我仍旧觉得有一些小小的遗憾。

---

## 五、操作系统
各大公司都对操作系统知识有所要求，目前的电子产品功能越来越多，也越来越复杂，OS可以极大地简化系统的开发难度。当然，目前仍旧有很多对可靠性要求极高的行业，会选用“裸奔”的方式进行开发。

> DJI：熟悉Linux内核（内存管理、进程管理、中断、锁、文件系统等）的开发及调试；精通至少一种嵌入式RTOS（如FreeRTOS、Threadx、Nucleus），有RTOS移植经验；精通实时性、调度抢占、中断优先级、中断嵌套、优先级翻转等问题。
> 美团：精通Linux内核，熟悉文件系统、进程调度、内存管理等内核基本概念；了解RTOS，对嵌入式实时操作系统任务调度等有一定了解。
> 小马智行：精通Linux、RTOS等操作系统，对操作系统运行机制有深刻理解。
> NINEBOT：有实际项目的RTOS应用经验，熟悉嵌入式操作系统线程模型、进程调度、内存管理机制；熟悉Linux Kernel和Android系统底层，熟悉RTOS的任务调度、消息队列、内存管理等机制。
> 石头科技：熟悉嵌入式操作系统理论，掌握实时操作系统（RTOS）或嵌入式Linux的任务调度、消息队列、内存管理等机制。
> 小米：熟悉Linux操作系统，对网络编程、进程通信、多线程编程有一定理解；有内存、功耗、性能优化、稳定性问题处理等经验。
> 地平线：熟悉多线程、多进程通信和调度，多任务内存管理，有中间件开发经历；了解QNX或AGL、AUTOSAR等相关知识

* RTOS：熟悉一个RTOS，可以说是嵌入式开发者的基本功。RTOS种类有很多（FreeRTOS/ThreadX/RTEMS/Nucleus/uCos），每种都有其设计哲学。上手一款RTOS其实并不难，毕竟大多数RTOS的复杂度要远小于Linux，并且很多RTOS已经提供了较为完善的porting指南。用好RTOS的挑战在于要造很多新的轮子。大多数RTOS没有log系统、崩溃时的core dump，性能profile工具（类似于Linux中的perf&trace）。所以在遇到问题时，调度难度较大。另外大部分RTOS中也缺少高速接口的驱动和协议栈（例如USB3.0）。现在在学习嵌入式的朋友中有一个误区，认为做RTOS的不如做Linux的，我并不完全认同。因为如果能把RTOS用好用溜，在RTOS上能搞定原本在Linux才能搞定的复杂功能，可以学到很多操作系统原理。从产品的竞争力角度来讲，RTOS开机时间快，占用的FLASH和DDR空间少，性能和成本均有一定的优势。
* Linux：有完善的生态，和异常活跃的开发者，生命力十足。用Linux容易，但用好很难，需要了解：内存管理、进程管理、多核、中断、锁、消息队列，性能分析等等内容。机器人视觉系统的要求通常会很极端：在全负荷运行时，对各类资源的占用率很高，CPU会跑到90%以上，内存空间的占用也会接近oom的阈值，内存带宽也几乎达到上限。此时系统会变得非常脆弱，极限的条件放大了每一个问题。当出现间歇性的帧率下降时，此时你会怀疑系统调度出现问题，内存出现泄漏，DDR带宽受限等等问题。如果不了解OS的底层原理，系统崩溃，人也跟着崩溃。另外，由于Linux的设计哲学是提供最大吞吐量，所以其关注的是一段时间的平均性能，允许出现秒级的性能抖动。所以Linux系统会默认打开一些功能，例如kmemleak/oom前的内存碎片整理，这些特性在极端情况下会导致系统秒级的卡死。而机器人视觉系统的要求则为毫秒级，此时应用会有秒级的时间没有响应，机器人会有秒级的时间失去观测，p 是非常危险的；而相机则会丢帧，影响用户体验。另外，Linux中的一些配置，也会极大影响系统性能，这里就不再多说，后续可以写专题文章介绍。
* C库：C库是经常被遗漏的知识点，C库承担了应用程序与OS内核的连接功能。系统调用API，符合posix标准的线程创建，都是由C库完成的。如果配置不好，会出现一些意想不到的问题。当然，这一般在RTOS中出现，Linux已经相对完善了。

---

## 六、接口与驱动
大部分同学应该是从调接口驱动开始的，这是一项基本功。刚开始学习嵌入式时，我曾狭隘地以为搞嵌入式就是写驱动。

> 美团无人配送：熟悉常用的总线通信与接口技术：CAN、SPI、I2C、UART、以太网等。
> 小马智行：熟悉SPI、I2C、UART、CAN、以太网等外设驱动。
> NINEBOT：掌握CAN，I2C，SPI，UART，TCP/IP等通信协议，并能熟练使用；3年以上的Android驱动经验，有LCD，Touch，Camera，USB，BT/WIFI/GPS Sensor，Power等驱动3种以上的开发经验，3年以上手机或其他嵌入式设备的产品化经验。
> 石头科技：熟练掌握UART、I2C、SPI、CAN、RS485等嵌入式系统常用总线接口和协议；至少熟悉LCD、Touch、Camera、USB、BT/WIFI/GPS、IMU及其他Sensor等外设中三种以上的驱动开发。

* 低速接口：UART，CAN，I2C，SPI是几种常见的低速接口。在机器人系统中，CAN因其高可靠的协议标准，一般会被用作总线，各处理器都挂在CAN上交互信息；I2C会用于各类sensor的config；SPI可以用于相对高速（数MHz到数十MHz）的数据通信。例如IMU在高速采样工作状态时，一般通过I2C进行配置，SPI进行数据传输。 低速接口的驱动在厂家提供的BSP中一般都有，只需要仔细看手册，搞清各接口所需的工作模式并做适当配置，该用中断的时候用中断，该用DMA的时候用DMA，不算太麻烦。
* 高速接口：USB，MIPI-CSI，MIPI-DSI，SDIO，ETH是几种常见的高速接口。相对低速接口，高速接口调起来相对复杂一些。一方面出问题调试时需要更高级的测试测量设备，另一方面高速接口的驱动通常要配合着后面的协议栈一起调试，协议栈相对会复杂一些。值得一提的是，得益于近年来移动处理器的高速发展，MIPI得到了越来越广泛的应用，Camera接口一般会采用MIPI-CSI。
* 在接触一个新的接口时，需要研究清楚该接口的接口协议。我之前面试过许多候选人，在使用I2C/SPI这些接口时，常常记不清楚这些接口有几根信号，这是不应该的。

BTW：NINEBOT和石头两位同学，你们的JD长得有点像呀？

---

## 七、Framework（中间件）
我把中间件和协议栈都放在本章介绍了。各机器人类企业一般会要求候选人熟悉ROS，相机类企业则要求熟悉camera/codec/storage相关的pipeline。

> 美团：熟悉boost等工具库的使用，熟悉TCP、UDP等协议，了解类ROS系统架构；熟悉视频编解码原理，熟悉GStreamer框架并在此框架下有实际开发经验。
> 小马智行：有机器人控制软件开发经验或者ROS使用经验者。
> NINEBOT：熟悉ROS源码，和对ROS的二次开发。
> 石头科技：熟悉ROS编程开发经验优先；
> OPPO：精通TCP/IP，UDP协议栈、熟悉http、coap、mqttt等常用通讯协议，熟悉SSL、TLS、DTLS等常用安全协议和原理，熟练掌握相关的网络编程经验；熟悉wifi 802.11协议原理；
> 
> 小米：熟悉音视频编编码，有H264/H265、aac/g711/pcm/mp3等编解码经验优先；熟悉ffmpeg、vlc、gstreamer等开源项目经验者优先；有camera驱动、HAL层及Framework层经验者;对android或linux架构及进程通信机制有研究，熟练掌握debug技巧者；熟悉Anroid Binder/Ashmem的使用及工作原理；熟悉内存管理、进程管理、文件系统、存储等子系统结构，具备综合系统分析能力

* ROS：自十年前诞生以来，先是在学术界广为应用，用于帮助研究者快速搭建机器人原型。随着ROS2的进步，开始慢慢走进工业界，很多公司的产品原型会选择使用ROS作为中间件进行搭建。ROS虽然叫做“机器人操作系统”，但它真的不是操作系统，而是一个中间件。它的核心是解决了多任务的通信问题。这与工业界一直在使用的DDS（Data Distribution Service）有一定的相似性。随着ROS的发展，开发者们为ROS添加了很多子功能系统，算法轮子，可以极大地提升原型开发效率。ROS2可以指定业界成熟的DDS作为其数据通信框架。ROS正一天一天变得强大，但是在终端产品中，我不推荐使用ROS。ROS发源于学术界，设计哲学是“快速实现一个能用的原型”，所以在多/快/好/省四个维度上，ROS强调的是多和快。你可以用他来很快地实现原型，但在产品化的过程中，你必须选择替代方案。当然，ROS也会一天天发展，但在现在这个时间点上，我还没有勇气坐上一台跑着ROS的自动驾驶汽车。
* Pipeline Framework：机器人视觉系统和相机系统都有一条核心的pipieline，最典型的就是ISP Pipeline。
* 协议栈：包含了网络，USB，文件系统等协议栈。协议栈用起来比较简单，但是用好很难。开源的协议栈性能一般都有较大的优化空间，各终端厂商为了满足其功能需求，会开展很多优化工作，例如华为对文件系统开展了很多优化工作。优化协议栈的工作相对比较专，需要耐得住寂寞一点一点啃，投身于此，值得敬佩！

---

## 八、算法优化
对运算性能要求较高的企业，都对算法优化技能提出了要求。其中DJI的JD写得最深入，基本上描述清了算法优化所需的各项技能点。

> DJI：精通DSP或NEON代码优化；熟悉vector C或intrinsic C编程；熟悉Cache、DMA等memory优化技能；具备GPU/CUDA软件开发经验。能充分发挥CPU、GPU、DDR、VPU等硬件的极限性能，提升系统流畅度和稳定性。
> 小马智行：精通计算机原理，能对代码进行面积优化或者性能优化。
> NINEBOT：嵌入式平台的算法开发/优化经验。
> 石头科技：有CUDA、OpenCL、OpenCV等开发经验者优先。
> OPPO：熟悉并行计算软件开发，熟悉SIMD原理，Cache原理和机制，熟悉DMA、中断等机制；较扎实的模式识别与机器学习理论基础者优先。
> 地平线：具有算法在嵌入式设备上的高效实现的相关经验；对机器学习、图像相关的技术有一定的了解，具有图像相关应用的从业经验；熟悉各种跟踪算法及其优化者优先；了解单目/多目视觉原理及其标定方法者优先。

算法优化分为三个层次，这三个层次需要按先后顺序逐步开展。

* 算法层：需要根据处理器的特性，选择最适合在该处理上运行的算法。例如两个实现相同功能的算法，一个适合并行，一个不适合并行，则优先选取适合并行的算法。再比如有些算法的实现，存在一些过设计（如太多的迭代次数），需要能及时识别出来。算法层的优化必须先做，在这一层可能能带来事半功倍的效果。所以嵌入式工程师需要懂相关算法的原理，否则容易被算法工程师唬住（大家别笑，这种事情其实经常发生）。
* 并行层：识别出代码中可以并行加速的部分，根据所用处理器的并行处理单元（NEON，DSP，GPU），使用vector C/intrinsic C/CUDA/openCL编写并行加速代码，最大限度提高并行运算单元利用率。
* 处理器层：如果编译器做得比较好，经过第二层，会得到优化效率很高的代码。但目前大部分编译器仍旧与人工书写的汇编有一定差距。所以针对热点代码，可以采用手写汇编的方式进行优化。但这一步，是优化到最后仍旧差一点点万不得已的办法，写汇编会耗费大量的时间精力，日后换处理器时还需要重写。处理器层除了汇编优化，还包括cache,DMA等memory相关的优化。memory的优化是经常被忽视的地方，通过提升内存的cache友好性是一件事半功倍的工作。

一般来讲，通过上面的三板斧，一般都会有几十倍的性能提升。所以当算法同事说每秒只能跑一帧的时候不要慌，三板斧下来，会有惊喜。

---

## 九、应用编程与调试
前面的几部分都是铺垫，所有的工作其实都是为了做出牛逼的应用。各企业对这部分的要求比较相似。

> 美团无人配送：具有Linux应用程序或设备驱动开发经验；
> 小马智行：熟悉嵌入式软件设计方法，有程序架构设计经验，对软件的模块化、可移植性有深入的理解
> NINEBOT：熟悉Linux或Unix系统编程，熟悉多进程/线程编程，了解基本的编译原理；握多线程及高性能的设计与编码及性能调优
> 小米：熟悉Linux下的代码调试工具，如gdb、valgrind、strace等；精通Crash&Dump分析，熟练掌握Trace32的使用，并会Debug脚本调试及Debug工具开发

* 应用编程：需要熟练地在各类OS下开展多线程，多进程的开发工作，了解进程间通信，线程间通信的方法。进程间通信是一件挺复杂的事情，涉及一对一，一对多，多对一，多对多等场景。同时又必须考虑通信的效率，逐步优化拷贝次数（两次-->一次-->零次）。DDS中间件就是专门用来通信的。应用编程需要特别注意这方面的坑。随之应用越来越复杂，又需要开展模块化/分层等工作。
* 调试：需要掌握gdb/valgrind/strace/perf/coredump等调试手段，用好log系统。不过我觉得使用工具属于招式，掌握前几章所中所讲的原理才是内功，要做到知其然知其所以然。

---

## 十、硬件知识
嵌入式工程师需要了解一定的硬件知识。了解硬件原理和相关的测试测量方法，相当于开了一个外挂，可以让你站在更高的维度思考整个系统。我之前有过一段硬件工程师的经历，对此深有体会。

> 美团无人配送：了解硬件原理及基础，具备电路原理图阅读能力；
> 小马智行：有传感器开发经验优先
> 
> NINEBOT：熟悉常见的传感器基本原理，如红外、超声波、lidar、相机、陀螺仪等；熟悉常见的模电、数电知识和自动控制理论，如PID的基本原理，卡尔曼滤波的基本方法等；
> 石头科技：熟悉模拟电子技术和数字电子技术等硬件知识，具备示波器、ICE、逻辑分析仪及其他相关设备的实际操作经验
> OPPO：具备一定的硬件分析能力，datasheet阅读能力；

* 硬件基础知识：可以看懂原理图，对常见的元器件有一定了解，熟悉模电和数电知识。这可以让你在遇到疑难问题时，多维度思考，避免在一颗树上吊死。之前我遇到的很多问题，都是软件和硬件共同导致的综合问题，如果没有一些硬件基础，是很难找到root cause的。
* 测试测量设备：掌握示波器，逻辑分析仪的使用，并了解其工作原理，会用各种触发模式。嵌入式工程师在编写驱动时，需要测量各信号是否满足规格，符合预期。另外，在一些高速总线的调试中，需要了解一些SI（信号完整性）的知识。
* 传感器：机器人系统需要用到各种各样的传感器，如Camera，IMU，TOF，指南针，气压计，超声波等等。每一个传感器都是一个小系统。就拿Camera来说，包含Camera Sensor，镜头，滤光片，Holder，调焦马达，FPC等部分，每一部分出问题都会导致图像的不理想。当然，会有专业的传感器工程师负责该部分的工作，但了解其中原理，有助于更好地优化整体系统。

---

## 十一、其他
这部分是一些软技能，各企业都或多或少会在JD中提一下。

> NINEBOT：具备机器人、电子设计、智能车大赛经验者优先(包含且不限于Robocon、Robocup 、RoboMaster、智能车大赛等)。
> 石头科技：积极、主动、严谨，对于Troubleshooting有不撞南墙不回头的刨根问底精神；较强的分析问题解决问题能力，能熟练调试固件程序，分析定位及解决复杂的固件、算法、硬件、结构等综合性技术问题。
> 地平线：优秀的书面和口头沟通技巧，良好的团队合作精神，工作主动性强；熟悉ASPICE和敏捷开发流程。

* 竞赛经验：现在的学科竞赛越来越多，为广大的同学提供了非常多历练的机会。我在读书的时候参加过很多比赛，几乎拿遍了所有等级的奖项。但我最大的收获却绝不是那几张奖状，而是能够和一群志同道合的朋友一起做成一件事情的经历，把看似不可能的目标变可能的冲动，迈出校园看外面世界的视野。 在后面的职业生涯中，我也比较偏爱有竞赛经历的同学，他们也在后续的工作中证明了自己的能力。
* 软技能：积极主动，合作导向，沟通顺畅，心态开放。这几乎是所有岗位都必须有的能力。这些软技能会成为你技术积累到一定瓶颈后向上发展的催化剂。拥有这些特质的人不管在什么岗位上，都是稀缺的，都是大有作为的。

本文献给：

* 还没有入行尚在迟疑嵌入式有没有前途的同学——你将了解嵌入式这个方向未来的路有多宽，有多么广阔的前景；
* 入行不久在某个方向陷入瓶颈的同学——你将了解你在未来还需要向哪些方向努力；
* 希望进入机器人视觉领域的嵌入式老鸟——希望本文能让你了解这个领域的关键挑战，并期待你带来新的思路。

由于作者知识所限，本文难免存在一些疏漏，希望您发现后不吝指出，感谢～

---

注：

欢迎转载，但转载请说明：转自知乎togo.huang的“机器人嵌入式系统设计”专栏，并附上链接。

发布于 2020-02-15 21:53

编辑于 2020-03-01 23:47
